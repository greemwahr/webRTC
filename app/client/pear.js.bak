'use strict';

window.addEventListener('load', startConnection(), false);

function startConnection() {
  signalingConnection();

  window.setTimeout(connectToPeers, 1000);

  function connectToPeers() {
    var listedPeers = [];
    $(document).ready($('ul').children().each(function () { listedPeers.push($(this).text());}));

    console.log('here are the listed peers:', listedPeers);
    var readyLength = ready.length;
    if (ready.indexOf(peerUserID, -1) === readyLength - 1) {
      listedPeers.forEach(function (peer) {
        var tmpPeer = Number(peer);
        rtcPeerConnection(tmpPeer);
      });
    }
  }
}

// Create a Web Socket connection to the signalling server @ url 'ws://localhost:8090'
function signalingConnection() {
  var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection ||
                          window.webkitRTCPeerConnection;
  var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription ||
                              window.webkitRTCSessionDescription;
  var RTCIceCandidate =  window.RTCIceCandidate || window.mozRTCIceCandidate;
  var servers = { iceServers: [{ urls: 'stun:stun.1.google.com:19302' }] };
  var wsUri = 'ws://localhost:8090/';
  var peerUserID = sessionStorage.tabID ? sessionStorage.tabID : sessionStorage.tabID =
                   Math.random();
  var signalingChannel = createSignalingChannel(wsUri, peerUserID);
  window.signalingChannel = signalingChannel;
  window.peerUserID = Number(peerUserID);

  // Checks for message with event onReady from Signalling server and lists them on the webpage
  signalingChannel.onReady = function (ready) {
    console.log('receiving the connected peers:', ready);
    $(document).ready($('li').remove());
    ready.filter(function (peer) {
      if (peer !== Number(peerUserID)) {return peer;}
    }).map(function (peer) {
      $('#listConnectedPeer').append('<li>' + '<a href="#">' + peer);
    });

    window.ready = ready;
  };

  // Creates a Web RTC peer connection to the remote peer
  function rtcPeerConnection(peerId) {
    var pc = new RTCPeerConnection(servers, {
      optional: [{
        DtlsSrtpKeyAgreement: true,
      }, ],
    });

    signalingChannel.onICECandidate = function (ICECandidate, source) {
      console.log('receiving ICE candidate from ', source);
      pc.addIceCandidate(new RTCIceCandidate(ICECandidate));
    };

    signalingChannel.onAnswer = function (answer, source) {
      console.log('receive answer from ', source);
      pc.setRemoteDescription(new RTCSessionDescription(answer));
    };

    pc.onicecandidate = function (evt) {
        if (evt.candidate) { // empty candidate (wirth evt.candidate === null) are often generated
          signalingChannel.sendICECandidate(evt.candidate, peerId);
        }
      };

    // Opens a data channel to the remote peer for commnunication
    //:warning the dataChannel must be opened BEFORE creating the offer.
    var _commChannel = pc.createDataChannel('communication', {
          reliable: false,
        });

    pc.createOffer(function (offer) {
          pc.setLocalDescription(offer);
          console.log('send offer');
          signalingChannel.sendOffer(offer, peerId);
        }, function (e) {

          console.error(e);
        });

    window.channel = _commChannel;

    _commChannel.onclose = function (evt) {
          console.log('dataChannel closed');
        };

    _commChannel.onerror = function (evt) {
          console.error('dataChannel error');
        };

    _commChannel.onopen = function () {
          console.log('dataChannel opened');
        };

    _commChannel.onmessage = function (message) {
          pearCallback(message.data);
        };
  }

  function createPeerConnection(peerId) {
    var pc = new RTCPeerConnection(servers, {
      optional: [{
        DtlsSrtpKeyAgreement: true,
      }, ],
    });

    pc.onicecandidate = function (evt) {
      if (evt.candidate) { // empty candidate (wirth evt.candidate === null) are often generated
        signalingChannel.sendICECandidate(evt.candidate, peerId);
      }
    };

    signalingChannel.onICECandidate = function (ICECandidate, source) {
      console.log('receiving ICE candidate from ', source);
      pc.addIceCandidate(new RTCIceCandidate(ICECandidate));
    };

    pc.ondatachannel = function (event) {
          var receiveChannel = event.channel;
          console.log('channel received');
          window.channel = receiveChannel;
          receiveChannel.onmessage = function (event) {
            messageCallback(event.data);
          };
        };

    return pc;
  }

  signalingChannel.onOffer = function (offer, source) {
    console.log('receive offer');
    var peerConnection = createPeerConnection(source);
    peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    peerConnection.createAnswer(function (answer) {
      peerConnection.setLocalDescription(answer);
      console.log('send answer');
      signalingChannel.sendAnswer(answer, source);
    }, function (e) {

      console.error(e);
    });
  };

  window.rtcPeerConnection = rtcPeerConnection;
}

// Handler for the transmission of data streams between two connected peers
function dataStream() {
  $('#viewpeer').text(message);

  $('#sendpeer').onclick = function () {
    var message = $('#peerText').val();
    channel.send(message);
  };
}
